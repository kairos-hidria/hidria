<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Canvas</title>
  <style>
    html, body { height:100%; margin:0; background:#0b0f17; color:rgba(255,255,255,.9); overflow:hidden; }
    #stage { position:absolute; inset:0; cursor:grab; }
    #viewport { position:absolute; left:0; top:0; transform-origin: 0 0; }
    svg { position:absolute; left:0; top:0; overflow:visible; }

    /* Top bar (back/home + optional help) */
    .bar{
      position:fixed; left:12px; top:12px; z-index:60;
      display:flex; gap:10px; align-items:flex-start;
      font:14px/1.4 system-ui, -apple-system, "Segoe UI", Roboto, "PingFang SC", "Microsoft YaHei", sans-serif;
    }
    .btn{
      cursor:pointer;
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      padding:10px 12px;
      color:rgba(255,255,255,.92);
      backdrop-filter: blur(10px);
      user-select:none;
      text-decoration:none;
      display:inline-block;
      white-space:nowrap;
    }
    .btn:hover{ border-color: rgba(160,210,255,.45); }

    .help{
      background:rgba(0,0,0,.30);
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px;
      padding:10px 12px;
      backdrop-filter: blur(10px);
      max-width:420px;
      display:none;
    }
    .help code{background:rgba(255,255,255,.08); padding:0 .35em; border-radius:8px;}

    .node {
      position:absolute;
      min-width:180px;
      max-width:520px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.14);
      border-radius:16px;
      box-shadow:0 12px 40px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      padding:12px 12px 10px;
      user-select:none;
    }
    .node .title { font-weight:800; margin:0 0 8px; font-size:14px; opacity:.95; }
    .node .body { font-size:13px; line-height:1.55; opacity:.86; white-space:pre-wrap; }
    .node a { color:rgba(160,210,255,.95); text-decoration:none; }
    .node a:hover { text-decoration:underline; }
    .dragging { outline:2px solid rgba(160,210,255,.55); }
  </style>
</head>

<body>
  <div class="bar">
    <!-- ✅ 回主站：你可以把 href 改成你想回去的页面，比如 /index.html 或 / -->
    <a class="btn" href="/" id="backBtn">← 返回主站</a>
    <div>
      <div class="btn" id="helpBtn">？帮助</div>
      <div class="help" id="helpBox">
        <div><b>Canvas Viewer</b></div>
        <div>打开：<code>/assets/canvas.html?src=路径.canvas</code></div>
        <div>拖拽节点 / 滚轮缩放 / 按住空白处拖动画布</div>
      </div>
    </div>
  </div>

  <div id="stage">
    <div id="viewport">
      <svg id="wires"></svg>
      <div id="nodes"></div>
    </div>
  </div>

<script>
(() => {
  const qs = new URLSearchParams(location.search);
  const src = qs.get("src") || "timeline.canvas"; // 默认文件名

  const stage = document.getElementById("stage");
  const viewport = document.getElementById("viewport");
  const nodesEl = document.getElementById("nodes");
  const wires = document.getElementById("wires");

  // help toggle
  const helpBtn = document.getElementById("helpBtn");
  const helpBox = document.getElementById("helpBox");
  helpBtn.addEventListener("click", () => {
    helpBox.style.display = (helpBox.style.display === "block") ? "none" : "block";
  });

  // view state
  let panX = 0, panY = 0, scale = 1;

  function applyTransform(){
    viewport.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
  }
  applyTransform();

  // pan
  let panning = false, panStart = null;
  stage.addEventListener("mousedown", (e) => {
    if (e.target.closest(".node")) return;
    panning = true;
    stage.style.cursor = "grabbing";
    panStart = { x: e.clientX, y: e.clientY, panX, panY };
  });
  window.addEventListener("mousemove", (e) => {
    if (!panning) return;
    panX = panStart.panX + (e.clientX - panStart.x);
    panY = panStart.panY + (e.clientY - panStart.y);
    applyTransform();
  });
  window.addEventListener("mouseup", () => {
    panning = false;
    stage.style.cursor = "grab";
  });

  // zoom
  stage.addEventListener("wheel", (e) => {
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    const factor = delta > 0 ? 0.92 : 1.08;
    const next = Math.min(2.0, Math.max(0.35, scale * factor));

    // zoom around mouse
    const rect = stage.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const worldX = (mx - panX) / scale;
    const worldY = (my - panY) / scale;

    scale = next;
    panX = mx - worldX * scale;
    panY = my - worldY * scale;

    applyTransform();
  }, { passive:false });

  // helpers
  function centerOf(el){
    const x = parseFloat(el.style.left) || 0;
    const y = parseFloat(el.style.top) || 0;
    const w = el.offsetWidth, h = el.offsetHeight;
    return { x: x + w/2, y: y + h/2 };
  }

  function safeBasename(p){
    const s = (p || "").replace(/\\/g,"/").split("/").filter(Boolean).pop() || "";
    return s || p || "";
  }

  function splitTextTitleBody(text){
    const t = (text || "").trim();
    if (!t) return { title: "文本", body: "" };
    const lines = t.split(/\r?\n/);
    const title = (lines[0] || "").trim() || "文本";
    const body = lines.slice(1).join("\n").trim();
    return { title, body };
  }

  const nodeMap = new Map();
  let edges = [];

  function drawWires(){
    wires.innerHTML = "";
    for (const e of edges){
      const a = nodeMap.get(e.fromNode);
      const b = nodeMap.get(e.toNode);
      if (!a || !b) continue;

      const A = centerOf(a.el);
      const B = centerOf(b.el);

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      const dx = Math.max(80, Math.abs(B.x - A.x) * 0.35);
      const c1x = A.x + dx, c1y = A.y;
      const c2x = B.x - dx, c2y = B.y;

      path.setAttribute("d", `M ${A.x} ${A.y} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${B.x} ${B.y}`);
      path.setAttribute("fill", "none");
      path.setAttribute("stroke", "rgba(160,210,255,.55)");
      path.setAttribute("stroke-width", "2");
      wires.appendChild(path);
    }
  }

  function createNode(n){
    const el = document.createElement("div");
    el.className = "node";
    el.style.left = (n.x ?? 0) + "px";
    el.style.top  = (n.y ?? 0) + "px";

    const title = document.createElement("div");
    title.className = "title";

    const body = document.createElement("div");
    body.className = "body";

    // --- title/body rules (✅ 不再显示 id) ---
    if (n.type === "text"){
      const tb = splitTextTitleBody(n.text || "");
      title.textContent = tb.title;
      body.textContent = tb.body; // 剩余内容放 body
    } else if (n.type === "file" && n.file){
      title.textContent = safeBasename(n.file);
      let href = n.file;

      // index.md → 目录
      if (/\/index\.md$/i.test(href)) href = href.replace(/index\.md$/i, "");
      // .md → .html
      else if (/\.md$/i.test(href)) href = href.replace(/\.md$/i, ".html");

      href = "/" + href.replace(/^\/+/, "");
      body.innerHTML = `文件：<a href="${href}">${n.file}</a>`;
    } else if (n.type === "link" && n.url){
      title.textContent = "外部链接";
      body.innerHTML = `链接：<a href="${n.url}" target="_blank" rel="noreferrer">${n.url}</a>`;
    } else {
      title.textContent = "节点";
      body.textContent = n.text || n.file || n.url || "";
    }

    el.appendChild(title);
    if ((body.textContent || body.innerHTML || "").trim()) el.appendChild(body);
    nodesEl.appendChild(el);

    // drag node
    let dragging = false, start = null;
    el.addEventListener("mousedown", (e) => {
      e.stopPropagation();
      dragging = true;
      el.classList.add("dragging");
      const x = parseFloat(el.style.left) || 0;
      const y = parseFloat(el.style.top) || 0;
      start = { mx:e.clientX, my:e.clientY, x, y };
    });
    window.addEventListener("mousemove", (e) => {
      if (!dragging) return;
      const dx = (e.clientX - start.mx) / scale;
      const dy = (e.clientY - start.my) / scale;
      el.style.left = (start.x + dx) + "px";
      el.style.top  = (start.y + dy) + "px";
      drawWires();
    });
    window.addEventListener("mouseup", () => {
      if (!dragging) return;
      dragging = false;
      el.classList.remove("dragging");
    });

    nodeMap.set(n.id, { el, data:n });
  }

  async function loadCanvas(){
    // ✅ 支持两种 src：
    // 1) 相对路径：hs/timeline/xxx.canvas
    // 2) 绝对 URL：https://hidria.pages.dev/hs/timeline/xxx.canvas
    const url = /^https?:\/\//i.test(src)
      ? src
      : ("/" + src.replace(/^\/+/,""));

    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`加载失败：${src} (${res.status})`);

    // 如果拿到的不是 JSON，会在这里报错（你之前的 < 就是这里）
    const data = await res.json();

    nodesEl.innerHTML = "";
    nodeMap.clear();

    for (const n of (data.nodes || [])) createNode(n);

    edges = (data.edges || []).map(e => ({
      fromNode: e.fromNode,
      toNode: e.toNode
    }));

    wires.setAttribute("width", "50000");
    wires.setAttribute("height", "50000");

    requestAnimationFrame(drawWires);
  }

  loadCanvas().catch(err => {
    alert(err.message + "\n\n用法：/assets/canvas.html?src=路径.canvas");
    console.error(err);
  });
})();
</script>
</body>
</html>
