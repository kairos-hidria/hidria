<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Canvas</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:rgba(255,255,255,.06);
      --panel2:rgba(255,255,255,.10);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --line:rgba(255,255,255,.12);
      --shadow:0 12px 40px rgba(0,0,0,.35);
      --r:18px;
      --accent:rgba(160,210,255,.95);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"PingFang SC","Noto Sans CJK SC","Microsoft YaHei",sans-serif;
      background:var(--bg);
      color:var(--text);
      overflow:hidden;
    }

    /* ===== Stage (Layer 1) ===== */
    #stage{
      position:fixed;
      inset:0;
      cursor:grab;
      z-index:1; /* layer 1 */
    }
    #stage.grabbing{ cursor:grabbing; }
    #viewport{ position:absolute; left:0; top:0; transform-origin:0 0; }
    svg{ position:absolute; left:0; top:0; overflow:visible; }

    /* ===== Sidebar (Layer 2) ===== */
    #side{
      position:fixed;
      left:0; top:0; bottom:0;
      width:320px; max-width:78vw;
      background:rgba(0,0,0,.30);
      border-right:1px solid var(--line);
      backdrop-filter: blur(12px);
      display:flex; flex-direction:column;
      z-index:200; /* layer 2 */
      transition: width .18s ease;
    }
    #side.collapsed{ width:56px; }

    #side .hdr{
      display:flex; align-items:center; gap:10px;
      padding:12px 12px;
      border-bottom:1px solid var(--line);
    }
    #toggle{
      width:34px; height:34px;
      border-radius:10px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.06);
      color:var(--text);
      cursor:pointer;
      display:grid; place-items:center;
      flex:0 0 auto;
    }
    #toggle:hover{ background:rgba(255,255,255,.10); }

    #sideTitle{
      font-weight:850;
      letter-spacing:.2px;
      font-size:14px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      flex:1;
      opacity:.95;
    }

    /* nav top */
    #nav{
      padding:10px 12px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      border-bottom:1px solid var(--line);
    }
    #side.collapsed #nav{ display:none; }

    .navlink{
      color:var(--muted);
      text-decoration:none;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid transparent;
      background:transparent;
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size:13px;
    }
    .navlink:hover{
      color:var(--text);
      border-color:var(--line);
      background:rgba(255,255,255,.06);
    }

    /* list */
    #list{
      padding:10px 8px 12px;
      overflow:auto;
      flex:1;
    }
    #side.collapsed #list{ display:none; }

    .item{
      display:flex; align-items:center; gap:10px;
      padding:10px 10px;
      border-radius:14px;
      border:1px solid transparent;
      cursor:pointer;
      user-select:none;
    }
    .item:hover{
      border-color:var(--line);
      background:rgba(255,255,255,.06);
    }
    .item.active{
      border-color:rgba(160,210,255,.30);
      background:rgba(160,210,255,.10);
    }
    .item .name{
      flex:1;
      color:rgba(255,255,255,.88);
      font-size:13px;
      line-height:1.2;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .item .src{
      color:var(--muted);
      font-size:12px;
      max-width:46%;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    /* ===== Nodes ===== */
    .node{
      position:absolute;
      min-width:180px;
      max-width:460px;
      background:var(--panel);
      border:1px solid rgba(255,255,255,.14);
      border-radius:16px;
      box-shadow:var(--shadow);
      backdrop-filter: blur(10px);
      padding:12px 12px 10px;
      user-select:none;
    }
    .node .title{
      font-weight:800;
      margin:0 0 8px;
      font-size:13px;
      opacity:.95;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .node .body{
      font-size:13px;
      line-height:1.55;
      opacity:.86;
      white-space:pre-wrap;
    }
    .node a{ color:var(--accent); text-decoration:none; }
    .node a:hover{ text-decoration:underline; }
    .dragging{ outline:2px solid rgba(160,210,255,.55); }

    /* collapsed hint strip */
    #collapsedHint{
      display:none;
      position:absolute;
      left:56px; top:12px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.30);
      color:rgba(255,255,255,.80);
      font-size:12px;
      backdrop-filter: blur(10px);
      white-space:nowrap;
    }
    #side.collapsed #collapsedHint{ display:block; }

    /* toast */
    #toast{
      position:fixed;
      left:50%;
      bottom:16px;
      transform:translateX(-50%);
      background:rgba(0,0,0,.38);
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px 12px;
      font-size:13px;
      color:rgba(255,255,255,.88);
      backdrop-filter: blur(10px);
      display:none;
      z-index:999;
      max-width:min(520px,92vw);
      text-align:center;
    }
  </style>
</head>
<body>

  <!-- Layer 2 -->
  <aside id="side">
    <div class="hdr">
      <button id="toggle" title="收起/展开">≡</button>
      <div id="sideTitle">时间轴画板</div>
    </div>
    <div id="collapsedHint">展开后可选画板</div>

    <nav id="nav">
      <a class="navlink" id="btnHome" href="/">返回主站</a>
      <a class="navlink" id="btnUp" href="/hs/timeline/">返回上级</a>
    </nav>

    <div id="list"></div>
  </aside>

  <!-- Layer 1 -->
  <div id="stage">
    <div id="viewport">
      <svg id="wires"></svg>
      <div id="nodes"></div>
    </div>
  </div>

  <div id="toast"></div>

<script>
(() => {
  const qs = new URLSearchParams(location.search);

  const stage = document.getElementById("stage");
  const viewport = document.getElementById("viewport");
  const nodesEl = document.getElementById("nodes");
  const wires = document.getElementById("wires");

  const listEl = document.getElementById("list");
  const side = document.getElementById("side");
  const toggle = document.getElementById("toggle");
  const toast = document.getElementById("toast");

  const btnHome = document.getElementById("btnHome");
  const btnUp = document.getElementById("btnUp");

  const DEFAULT_NAV = "/hs/timeline/index";
  let src = qs.get("src") || "hs/timeline/all-timelines.canvas";
  let nav = qs.get("nav") || DEFAULT_NAV;

  // view state
  let panX = 0, panY = 0, scale = 1;
  function applyTransform(){
    viewport.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
  }
  applyTransform();

  // ===== Fit-to-content (auto center) =====
  let __lastData = null;
  function clamp(v, a, b){ return Math.min(b, Math.max(a, v)); }
  function getSidebarWidth(){
    // expanded 320, collapsed 56
    return side.classList.contains("collapsed") ? 56 : 320;
  }
  function fitToContent(data){
    if (!data || !data.nodes || !data.nodes.length) return;

    // Use canvas JSON coordinates directly (stable, no DOM measurement race)
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const n of data.nodes){
      const x = n.x ?? 0;
      const y = n.y ?? 0;
      const w = n.width ?? 240;
      const h = n.height ?? 120;
      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x + w);
      maxY = Math.max(maxY, y + h);
    }
    const bw = maxX - minX;
    const bh = maxY - minY;
    if (bw <= 0 || bh <= 0) return;

    const margin = 32;
    const sw = getSidebarWidth();
    const vw = Math.max(120, window.innerWidth - sw - margin * 2);
    const vh = Math.max(120, window.innerHeight - margin * 2);

    // fit scale
    scale = clamp(Math.min(vw / bw, vh / bh), 0.35, 2.0);

    // center
    panX = sw + margin + (vw - bw * scale) / 2 - minX * scale;
    panY = margin + (vh - bh * scale) / 2 - minY * scale;

    applyTransform();
  }

  function showToast(msg){
    toast.textContent = msg;
    toast.style.display = "block";
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toast.style.display = "none", 1600);
  }

  function normalizePath(p){
    if(!p) return "";
    if (p.startsWith("http://") || p.startsWith("https://")) return p;
    if (!p.startsWith("/")) return "/" + p;
    return p;
  }

  function deduceUpFromSrc(){
    const clean = src.replace(/^\/+/, "");
    const parts = clean.split("/");
    parts.pop();
    const up = "/" + parts.join("/") + "/";
    return up === "//" ? "/" : up;
  }

  toggle.addEventListener("click", () => {
    side.classList.toggle("collapsed");
    // wait sidebar width transition then refit
    setTimeout(() => fitToContent(__lastData), 220);
  });

  // pan
  let panning = false, panStart = null;
  stage.addEventListener("mousedown", (e) => {
    if (e.target.closest(".node")) return;
    panning = true;
    stage.classList.add("grabbing");
    panStart = { x: e.clientX, y: e.clientY, panX, panY };
  });
  window.addEventListener("mousemove", (e) => {
    if (!panning) return;
    panX = panStart.panX + (e.clientX - panStart.x);
    panY = panStart.panY + (e.clientY - panStart.y);
    applyTransform();
  });
  window.addEventListener("mouseup", () => {
    panning = false;
    stage.classList.remove("grabbing");
  });

  // zoom
  stage.addEventListener("wheel", (e) => {
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    const factor = delta > 0 ? 0.92 : 1.08;
    const next = Math.min(2.0, Math.max(0.35, scale * factor));

    const rect = stage.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const worldX = (mx - panX) / scale;
    const worldY = (my - panY) / scale;

    scale = next;
    panX = mx - worldX * scale;
    panY = my - worldY * scale;

    applyTransform();
  }, { passive:false });

  // keep view stable on resize (refit to content)
  window.addEventListener("resize", () => fitToContent(__lastData));

  function centerOf(el){
    const x = parseFloat(el.style.left) || 0;
    const y = parseFloat(el.style.top) || 0;
    const w = el.offsetWidth, h = el.offsetHeight;
    return { x: x + w/2, y: y + h/2 };
  }

  const nodeMap = new Map();
  let edges = [];

  function drawWires(){
    wires.innerHTML = "";
    for (const e of edges){
      const a = nodeMap.get(e.fromNode);
      const b = nodeMap.get(e.toNode);
      if (!a || !b) continue;

      const A = centerOf(a.el);
      const B = centerOf(b.el);

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      const dx = Math.max(80, Math.abs(B.x - A.x) * 0.35);
      const c1x = A.x + dx, c1y = A.y;
      const c2x = B.x - dx, c2y = B.y;

      path.setAttribute("d", `M ${A.x} ${A.y} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${B.x} ${B.y}`);
      path.setAttribute("fill", "none");
      path.setAttribute("stroke", "rgba(160,210,255,.55)");
      path.setAttribute("stroke-width", "2");
      wires.appendChild(path);
    }
  }

  // ===== Title rules (NO id for text nodes; never show id) =====
  function titleForNode(n){
    if (n.type === "text") return ""; // text nodes: no title, no id
    if (n.label && String(n.label).trim()) return String(n.label).trim();
    if (n.type === "file" && n.file) return String(n.file).split("/").pop();
    return ""; // never fallback to id
  }

  function createNode(n){
    const el = document.createElement("div");
    el.className = "node";

    el.style.left = (n.x ?? 0) + "px";
    el.style.top  = (n.y ?? 0) + "px";

    // If canvas provides explicit width/height, respect it (optional)
    if (n.width != null) el.style.width = n.width + "px";
    if (n.height != null) el.style.minHeight = n.height + "px";

    const t = titleForNode(n);
    if (t){
      const title = document.createElement("div");
      title.className = "title";
      title.textContent = t;
      el.appendChild(title);
    }

    const body = document.createElement("div");
    body.className = "body";

    if (n.type === "text"){
      // text node: ONLY content, no duplicate
      body.textContent = n.text || "";
    } else if (n.type === "file" && n.file){
      let href = n.file;

      // md routing:
      if (/\/index\.md$/i.test(href)) href = href.replace(/index\.md$/i, "");
      else if (/\.md$/i.test(href)) href = href.replace(/\.md$/i, ".html");

      href = normalizePath(href);
      body.innerHTML = `文件：<a href="${href}">${n.file}</a>`;
    } else if (n.type === "link" && n.url){
      body.innerHTML = `链接：<a href="${n.url}" target="_blank" rel="noreferrer">${n.url}</a>`;
    } else {
      body.textContent = n.text || n.file || n.url || "";
    }

    el.appendChild(body);
    nodesEl.appendChild(el);

    // drag node
    let dragging = false, start = null;
    el.addEventListener("mousedown", (e) => {
      e.stopPropagation();
      dragging = true;
      el.classList.add("dragging");
      const x = parseFloat(el.style.left) || 0;
      const y = parseFloat(el.style.top) || 0;
      start = { mx:e.clientX, my:e.clientY, x, y };
    });
    window.addEventListener("mousemove", (e) => {
      if (!dragging) return;
      const dx = (e.clientX - start.mx) / scale;
      const dy = (e.clientY - start.my) / scale;
      el.style.left = (start.x + dx) + "px";
      el.style.top  = (start.y + dy) + "px";
      drawWires();
    });
    window.addEventListener("mouseup", () => {
      if (!dragging) return;
      dragging = false;
      el.classList.remove("dragging");
    });

    nodeMap.set(n.id, { el, data:n });
  }

  function clearCanvas(){
    nodesEl.innerHTML = "";
    wires.innerHTML = "";
    nodeMap.clear();
    edges = [];
  }

  async function loadCanvas(path){
    src = path || src;
    btnUp.href = deduceUpFromSrc();

    const url = normalizePath(src.replace(/^\/+/, ""));
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`加载失败：${src} (${res.status})`);

    const data = await res.json();
    __lastData = data;

    clearCanvas();
    for (const n of (data.nodes || [])) createNode(n);

    edges = (data.edges || []).map(e => ({ fromNode: e.fromNode, toNode: e.toNode }));

    wires.setAttribute("width", "50000");
    wires.setAttribute("height", "50000");

    // draw wires after DOM layout then fit to content (ensures center not empty)
    requestAnimationFrame(() => {
      drawWires();
      fitToContent(__lastData);
    });

    const u = new URL(location.href);
    u.searchParams.set("src", src);
    u.searchParams.set("nav", nav);
    history.replaceState({}, "", u.toString());
  }

  function setActiveItem(activeSrc){
    [...listEl.querySelectorAll(".item")].forEach(el => {
      el.classList.toggle("active", el.dataset.src === activeSrc);
    });
  }

  async function loadNavFromPage(navPath){
    nav = navPath || nav;
    const navUrl = normalizePath(nav);
    const res = await fetch(navUrl, { cache: "no-store" });
    if (!res.ok) throw new Error(`目录页加载失败：${nav} (${res.status})`);

    const html = await res.text();
    const doc = new DOMParser().parseFromString(html, "text/html");
    const links = [...doc.querySelectorAll("a[href]")];

    const items = [];
    for (const a of links){
      const href = a.getAttribute("href") || "";
      if (!href.includes("/assets/canvas.html")) continue;

      try{
        const abs = new URL(href, location.origin);
        const s = abs.searchParams.get("src");
        if (!s) continue;
        if (!s.endsWith(".canvas")) continue;

        items.push({
          label: (a.textContent || "").trim() || s,
          src: s
        });
      }catch(_){}
    }

    listEl.innerHTML = "";
    if (!items.length){
      listEl.innerHTML = `<div style="padding:10px 12px; color:rgba(255,255,255,.75); font-size:13px; line-height:1.5">
        目录为空：请在 <b>${nav}</b> 里写 <code>/assets/canvas.html?src=...</code> 的链接。
      </div>`;
      return;
    }

    for (const it of items){
      const row = document.createElement("div");
      row.className = "item";
      row.dataset.src = it.src;

      const name = document.createElement("div");
      name.className = "name";
      name.textContent = it.label;

      const small = document.createElement("div");
      small.className = "src";
      small.textContent = it.src.split("/").pop();

      row.appendChild(name);
      row.appendChild(small);

      row.addEventListener("click", async () => {
        await loadCanvas(it.src);
        setActiveItem(it.src);
        showToast("已切换画板：" + it.label);
      });

      listEl.appendChild(row);
    }

    setActiveItem(src);
  }

  async function boot(){
    btnUp.href = deduceUpFromSrc();
    await loadNavFromPage(nav).catch(()=>{});
    await loadCanvas(src);
    setActiveItem(src);
  }

  boot().catch(err => {
    alert(err.message);
    console.error(err);
  });
})();
</script>
</body>
</html>
