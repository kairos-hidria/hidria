<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Canvas</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:rgba(255,255,255,.06);
      --panel2:rgba(255,255,255,.10);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --line:rgba(255,255,255,.12);
      --shadow:0 12px 40px rgba(0,0,0,.35);
      --r:18px;
      --accent:rgba(160,210,255,.95);
      --accent2:rgba(160,210,255,.55);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"PingFang SC","Noto Sans CJK SC","Microsoft YaHei",sans-serif;
      background:var(--bg);
      color:var(--text);
      overflow:hidden;
    }

    /* layout */
    #app{position:absolute; inset:0; display:flex}
    #side{
      width:320px; max-width:78vw;
      border-right:1px solid var(--line);
      background:rgba(0,0,0,.22);
      backdrop-filter: blur(10px);
      display:flex; flex-direction:column;
      transition: width .18s ease;
    }
    #side.collapsed{ width:56px; }
    #side .hdr{
      display:flex; align-items:center; gap:10px;
      padding:12px 12px;
      border-bottom:1px solid var(--line);
    }
    #side .hdr .ttl{
      font-weight:800;
      letter-spacing:.2px;
      font-size:14px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      flex:1;
      opacity:.95;
    }
    #toggle{
      width:34px; height:34px;
      border-radius:10px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.06);
      color:var(--text);
      cursor:pointer;
      display:grid; place-items:center;
    }
    #toggle:hover{ background:rgba(255,255,255,.10); }

    #side .actions{
      display:flex; gap:8px;
      padding:10px 12px;
      border-bottom:1px solid var(--line);
    }
    #side.collapsed .actions{ display:none; }

    .btn{
      display:inline-flex; align-items:center; gap:8px;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.06);
      color:var(--text);
      text-decoration:none;
      font-size:13px;
      cursor:pointer;
      user-select:none;
    }
    .btn:hover{ background:rgba(255,255,255,.10); }

    #list{
      padding:10px 8px 12px;
      overflow:auto;
    }
    #side.collapsed #list{ display:none; }

    .item{
      display:flex; align-items:center; gap:10px;
      padding:10px 10px;
      border-radius:14px;
      border:1px solid transparent;
      cursor:pointer;
      user-select:none;
    }
    .item:hover{
      border-color:var(--line);
      background:rgba(255,255,255,.06);
    }
    .item.active{
      border-color:rgba(160,210,255,.30);
      background:rgba(160,210,255,.10);
    }
    .item .name{
      flex:1;
      color:rgba(255,255,255,.88);
      font-size:13px;
      line-height:1.2;
    }
    .item .src{
      color:var(--muted);
      font-size:12px;
      max-width:40%;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    /* stage */
    #stage{
      position:relative;
      flex:1;
      cursor:grab;
    }
    #stage.grabbing{ cursor:grabbing; }
    #viewport{ position:absolute; left:0; top:0; transform-origin:0 0; }
    svg{ position:absolute; left:0; top:0; overflow:visible; }

    /* nodes */
    .node{
      position:absolute;
      min-width:180px;
      max-width:460px;
      background:var(--panel);
      border:1px solid rgba(255,255,255,.14);
      border-radius:16px;
      box-shadow:var(--shadow);
      backdrop-filter: blur(10px);
      padding:12px 12px 10px;
      user-select:none;
    }
    .node .title{
      font-weight:800;
      margin:0 0 8px;
      font-size:13px;
      opacity:.95;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .node .body{
      font-size:13px;
      line-height:1.55;
      opacity:.86;
      white-space:pre-wrap;
    }
    .node a{ color:var(--accent); text-decoration:none; }
    .node a:hover{ text-decoration:underline; }
    .dragging{ outline:2px solid rgba(160,210,255,.55); }

    /* small toast */
    #toast{
      position:fixed;
      left:50%;
      bottom:16px;
      transform:translateX(-50%);
      background:rgba(0,0,0,.38);
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px 12px;
      font-size:13px;
      color:rgba(255,255,255,.88);
      backdrop-filter: blur(10px);
      display:none;
      z-index:99;
      max-width:min(520px,92vw);
      text-align:center;
    }

    @media (max-width:760px){
      #side{ width:280px; }
    }
  </style>
</head>
<body>
<div id="app">
  <aside id="side">
    <div class="hdr">
      <button id="toggle" title="收起/展开">≡</button>
      <div class="ttl" id="sideTitle">时间轴画板</div>
    </div>
    <div class="actions">
      <a class="btn" id="btnHome" href="/">返回主站</a>
      <a class="btn" id="btnUp" href="/hs/timeline/">返回上级</a>
    </div>
    <div id="list"></div>
  </aside>

  <div id="stage">
    <div id="viewport">
      <svg id="wires"></svg>
      <div id="nodes"></div>
    </div>
  </div>
</div>

<div id="toast"></div>

<script>
(() => {
  const qs = new URLSearchParams(location.search);
  const stage = document.getElementById("stage");
  const viewport = document.getElementById("viewport");
  const nodesEl = document.getElementById("nodes");
  const wires = document.getElementById("wires");
  const listEl = document.getElementById("list");
  const side = document.getElementById("side");
  const toggle = document.getElementById("toggle");
  const sideTitle = document.getElementById("sideTitle");
  const btnHome = document.getElementById("btnHome");
  const btnUp = document.getElementById("btnUp");
  const toast = document.getElementById("toast");

  // defaults
  const DEFAULT_NAV = "/hs/timeline/index";
  let src = qs.get("src") || "hs/timeline/all-timelines.canvas";
  let nav = qs.get("nav") || DEFAULT_NAV;

  // view state
  let panX = 0, panY = 0, scale = 1;
  function applyTransform(){
    viewport.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
  }
  applyTransform();

  function showToast(msg){
    toast.textContent = msg;
    toast.style.display = "block";
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toast.style.display = "none", 2200);
  }

  function normalizePath(p){
    if(!p) return "";
    // allow absolute like /hs/xxx or relative hs/xxx
    if (p.startsWith("http://") || p.startsWith("https://")) return p;
    if (!p.startsWith("/")) return "/" + p;
    return p;
  }

  function deduceUpFromSrc(){
    const clean = src.replace(/^\/+/, "");
    const parts = clean.split("/");
    parts.pop();
    const up = "/" + parts.join("/") + "/";
    return up === "//" ? "/" : up;
  }

  // sidebar toggle
  toggle.addEventListener("click", () => {
    side.classList.toggle("collapsed");
  });

  // pan
  let panning = false, panStart = null;
  stage.addEventListener("mousedown", (e) => {
    if (e.target.closest(".node")) return;
    panning = true;
    stage.classList.add("grabbing");
    panStart = { x: e.clientX, y: e.clientY, panX, panY };
  });
  window.addEventListener("mousemove", (e) => {
    if (!panning) return;
    panX = panStart.panX + (e.clientX - panStart.x);
    panY = panStart.panY + (e.clientY - panStart.y);
    applyTransform();
  });
  window.addEventListener("mouseup", () => {
    panning = false;
    stage.classList.remove("grabbing");
  });

  // zoom
  stage.addEventListener("wheel", (e) => {
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    const factor = delta > 0 ? 0.92 : 1.08;
    const next = Math.min(2.0, Math.max(0.35, scale * factor));

    const rect = stage.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const worldX = (mx - panX) / scale;
    const worldY = (my - panY) / scale;

    scale = next;
    panX = mx - worldX * scale;
    panY = my - worldY * scale;

    applyTransform();
  }, { passive:false });

  // helpers
  function centerOf(el){
    const x = parseFloat(el.style.left) || 0;
    const y = parseFloat(el.style.top) || 0;
    const w = el.offsetWidth, h = el.offsetHeight;
    return { x: x + w/2, y: y + h/2 };
  }

  const nodeMap = new Map();
  let edges = [];

  function drawWires(){
    wires.innerHTML = "";
    for (const e of edges){
      const a = nodeMap.get(e.fromNode);
      const b = nodeMap.get(e.toNode);
      if (!a || !b) continue;

      const A = centerOf(a.el);
      const B = centerOf(b.el);

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      const dx = Math.max(80, Math.abs(B.x - A.x) * 0.35);
      const c1x = A.x + dx, c1y = A.y;
      const c2x = B.x - dx, c2y = B.y;

      path.setAttribute("d", `M ${A.x} ${A.y} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${B.x} ${B.y}`);
      path.setAttribute("fill", "none");
      path.setAttribute("stroke", "rgba(160,210,255,.55)");
      path.setAttribute("stroke-width", "2");
      wires.appendChild(path);
    }
  }

  function nodeTitle(n){
    // priority: label > file > first line of text > (no id unless absolutely needed)
    if (n.label && String(n.label).trim()) return String(n.label).trim();
    if (n.type === "file" && n.file) return String(n.file).split("/").pop();
    if (n.type === "text" && n.text){
      const t = String(n.text).trim();
      if (t) return t.split("\n")[0].slice(0, 60);
    }
    return "node";
  }

  function createNode(n){
    const el = document.createElement("div");
    el.className = "node";
    el.style.left = (n.x ?? 0) + "px";
    el.style.top  = (n.y ?? 0) + "px";

    const title = document.createElement("div");
    title.className = "title";
    title.textContent = nodeTitle(n);

    const body = document.createElement("div");
    body.className = "body";

    if (n.type === "text"){
      body.textContent = n.text || "";
    } else if (n.type === "file" && n.file){
      let href = n.file;

      // index.md -> directory
      if (/\/index\.md$/i.test(href)) href = href.replace(/index\.md$/i, "");
      // md -> html
      else if (/\.md$/i.test(href)) href = href.replace(/\.md$/i, ".html");

      href = normalizePath(href);
      body.innerHTML = `文件：<a href="${href}">${n.file}</a>`;
    } else if (n.type === "link" && n.url){
      body.innerHTML = `链接：<a href="${n.url}" target="_blank" rel="noreferrer">${n.url}</a>`;
    } else {
      body.textContent = n.text || n.file || n.url || "";
    }

    el.appendChild(title);
    el.appendChild(body);
    nodesEl.appendChild(el);

    // drag node
    let dragging = false, start = null;
    el.addEventListener("mousedown", (e) => {
      e.stopPropagation();
      dragging = true;
      el.classList.add("dragging");
      const x = parseFloat(el.style.left) || 0;
      const y = parseFloat(el.style.top) || 0;
      start = { mx:e.clientX, my:e.clientY, x, y };
    });
    window.addEventListener("mousemove", (e) => {
      if (!dragging) return;
      const dx = (e.clientX - start.mx) / scale;
      const dy = (e.clientY - start.my) / scale;
      el.style.left = (start.x + dx) + "px";
      el.style.top  = (start.y + dy) + "px";
      drawWires();
    });
    window.addEventListener("mouseup", () => {
      if (!dragging) return;
      dragging = false;
      el.classList.remove("dragging");
    });

    nodeMap.set(n.id, { el, data:n });
  }

  function clearCanvas(){
    nodesEl.innerHTML = "";
    wires.innerHTML = "";
    nodeMap.clear();
    edges = [];
  }

  async function loadCanvas(path){
    src = path || src;
    // update up link
    btnUp.href = deduceUpFromSrc();

    const url = normalizePath(src.replace(/^\/+/, ""));
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`加载失败：${src} (${res.status})`);

    const data = await res.json();

    clearCanvas();

    for (const n of (data.nodes || [])){
      createNode(n);
    }
    edges = (data.edges || []).map(e => ({
      fromNode: e.fromNode,
      toNode: e.toNode
    }));

    wires.setAttribute("width", "50000");
    wires.setAttribute("height", "50000");
    requestAnimationFrame(drawWires);

    // keep URL in sync (so you can copy current link)
    const u = new URL(location.href);
    u.searchParams.set("src", src);
    u.searchParams.set("nav", nav);
    history.replaceState({}, "", u.toString());
  }

  function setActiveItem(activeSrc){
    [...listEl.querySelectorAll(".item")].forEach(el => {
      el.classList.toggle("active", el.dataset.src === activeSrc);
    });
  }

  async function loadNavFromPage(navPath){
    nav = navPath || nav;
    // we fetch rendered html. your rewriter makes /hs/timeline/index work as html route.
    const navUrl = normalizePath(nav);
    const res = await fetch(navUrl, { cache: "no-store" });
    if (!res.ok) throw new Error(`目录页加载失败：${nav} (${res.status})`);

    const html = await res.text();
    const doc = new DOMParser().parseFromString(html, "text/html");
    const links = [...doc.querySelectorAll("a[href]")];

    // pick all links that point to this canvas viewer and have src=...
    const items = [];
    for (const a of links){
      const href = a.getAttribute("href") || "";
      if (!href.includes("/assets/canvas.html")) continue;
      try{
        const abs = new URL(href, location.origin);
        const s = abs.searchParams.get("src");
        if (!s) continue;
        // keep only .canvas targets (optional but safer)
        if (!s.endsWith(".canvas")) continue;

        items.push({
          label: (a.textContent || "").trim() || s,
          src: s
        });
      }catch(_){}
    }

    // render list
    listEl.innerHTML = "";
    if (!items.length){
      listEl.innerHTML = `<div style="padding:10px 12px; color:rgba(255,255,255,.75); font-size:13px; line-height:1.5">
        目录为空：请在 <b>${nav}</b> 里写 <code>/assets/canvas.html?src=...</code> 的链接。
      </div>`;
      return;
    }

    for (const it of items){
      const row = document.createElement("div");
      row.className = "item";
      row.dataset.src = it.src;

      const name = document.createElement("div");
      name.className = "name";
      name.textContent = it.label;

      const small = document.createElement("div");
      small.className = "src";
      small.textContent = it.src.split("/").pop();

      row.appendChild(name);
      row.appendChild(small);

      row.addEventListener("click", async () => {
        try{
          await loadCanvas(it.src);
          setActiveItem(it.src);
          showToast("已切换画板：" + it.label);
        }catch(err){
          alert(err.message);
          console.error(err);
        }
      });

      listEl.appendChild(row);
    }

    // set active
    setActiveItem(src);
  }

  async function boot(){
    // basic links
    btnHome.href = "/";
    btnUp.href = deduceUpFromSrc();

    // title can be customized by nav page title, but keep simple:
    sideTitle.textContent = "时间轴画板";

    try{
      await loadNavFromPage(nav);
    }catch(err){
      console.warn(err);
      // still try load canvas even if nav fails
    }

    try{
      await loadCanvas(src);
      setActiveItem(src);
    }catch(err){
      alert(err.message + "\n\n你可以检查：\n1) .canvas 是否已被部署（路径能打开）\n2) 链接里的 src 是否正确\n3) nav 页面是否存在");
      console.error(err);
    }
  }

  boot();
})();
</script>
</body>
</html>
